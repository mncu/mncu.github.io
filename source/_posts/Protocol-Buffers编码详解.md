---
title: Protocol Buffers编码详解
date: 2021-01-06 20:47:40
tags:
- ProtocolBuffers
- Varint
- ZigZag
- encode
---

### 基本介绍

#### 本节要讲的内容

有关`Protocol Buffers`的各种demo这个网上已经很多了，所以本文目的并不在于讲解如何实现一个`Protocol Buffers`的demo

本文主要是讲解一下`Protocol Buffers`的编码方式，让大家知道为什么`Protocol Buffers`会"更快"。

本文主要是介绍原理，重点在于根据原理学习这种“优化”方式，所以本文中的部分代码实现可以选择性跳过。

#### 什么是Protocol Buffers
> Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据序列化，很适合做数据存储或 RPC 数据交换格式。它可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。

ps: 当前主要存在两个版本，分别是`Protocol Buffers2`以及`Protocol Buffers3`，因为`Protocol Buffers3` 比 `Protocol Buffers2` 支持更多语言和功能，同时去掉了一些复杂的语法和特性，更强调约定而弱化语法。因此本文中主要根据`Protocol Buffers3`进行讲解

可以大体知道`Protocol Buffers`和`JSON`类似，都是一种数据系列化协议，那么相较于其他的数据系列化协议他有什么优点呢？

#### Protocol Buffers的优点和缺点

优点和缺点都是通过比较来得出的，我们暂时就拿现在较为流行的另一个序列化协议`JSON`和`Protocol Buffers`做一下比较。

相较于`JSON`来说，`Protocol Buffers`：

1. 一般来说更小
2. 一般来说更快
3. 一般来说会更加麻烦

前两条是优点，之所以会加上“一般来说”这种限定条件是因为某些特殊情况下`Protocol Buffers`并不总是会比`JSON`更小更快，至于原因下文中会叙述。

第三条则是`Protocol Buffers`为了达到前两条的优点对复杂性做了妥协。毕竟，计算机的发展就是在不断的妥协；得到总是伴随着失去。`Protocol Buffers`之所以更加麻烦是因为在使用`Protocol Buffers`时，需要传输端以及接收端事先定义好数据格式，也就是写一下`.proto`文件。而`JSON`则简单得多，通信双方事先不需要知道数据格式，只要数据符合`JSON`协议规范则都可以正常解析。

### 引入

现代API往往会返回一个或者多个对象，又因为每个对象一般包含了多个属性，所以我们往往习惯于使用**key value**的方式来表达数据。

比如说我们要获取一个人的个人信息，这个“人”是一个对象，他具有“姓名”，“年龄”......等各种属性(attribute)，所以我们的数据往往会表达成这种样子：

```
name: A
age: 18

```

而上面的信息通过`JSON`编码后：
```json
{
    "name": "A",
    "age": 18
}
```

但是，真正对信息需求方来说，**只有`value`才是其真正想要的值，在这里我们称之为"目标数据"，而`key`则仅仅是用来区分`value`所代表的含义的**，所以：
- `value`目标数据
- `key`非目标数据

另外，通过`JSON`编码后，我们发现数据已经多了很多的其他字符，比如`"`,`{}`,`:`，`,`，这些字符存在的意义在于作为**分隔符或者说边界**区分`key`与`value`，或者是`attribute`与`attribute`。这些分隔符也作为非目标数据存在。

那么如何将对其简化呢？

- 降低非目标数据所占比例
- 降低目标数据所占空间大小


`Protocol Buffers`是如何做的呢？
1. `key`使用正整数表示，同时对所有整数进行特殊编码，节省空间。不论该整数是`key`还是`value`
2. 所有数据类型在“数据编码”层面实现"分隔符"，不使用额外的字符作为“分隔符”。

事实上`Protocol Buffers`对字符串、整数、repeated字段都做了特殊编码，但之所以在第一点重点突出整型的作用，是因为个人认为`Protocol Buffers`的整型编码是其余类型编码的基石，因此会着重讲一下整型编码的实现原理。至于其他类型编码则相对简单一些，明白了整型编码后就会很容易理解。

所以接下来直接讲解整型编码。

### 整型编码

一般来说，整数在计算机的存储空间是固定的，`int32`占用4个字节,`int64`则占用8个字节。但是这样对于比较小的整数来说则较为浪费。

我们以类型为`uint32`的数字`1`为例:
```
00000000 00000000 00000000 00000001
```
我们可以看到，左侧的3个字节的`0`都是无意义的填充，真正的有效字节是最低位也就是最右侧的字节。

那么能够有一种编码方式让我们能根据数字的值动态调整其所占空间大小呢？

#### Varint

Varint主要目的是对**无符号整数**进行压缩，以便更好的传输/存储整数数据。一个整数会消耗1个或者多个字节不等，一般来说，越小的整数消耗的字节数量越小。

Varint编码格式每个字节可分为：
- 标志位，每个字节的最高有效位
    - 标志位为0，表示该字节为尾部
    - 标志位为1，表示未结束
- 数据存储位，除最高有效位以外的其他位

ps：因为有额外的标志位，所以也会出现一个正常来说可以用4个字节表示的整数在Varint编码后所需字节大于4个的情况。但如果我们能确定所传输的整数大多数为较小的数字的话，这个缺点就可以接受。

接下来看一个实际的例子。

- 数字1
```
# 这个很简单，标志位也就是最高有效位是0，数据存储位为1
0 0000001
```
- 数字300
```
1 0101100 0 0000010

# 300占用了两个字节，第一个字节的标志位为1所以说明还没有结束，需要读取下一个字节，第二个字节标志位为0，表示结束，所以共有两个字节。
# 然后去除两个标志位，得到 0101100 0000010，也就是 100101100, 256 + 32 + 8 + 4 = 300
```

在上面的例子中我们都是在用无符号整数举例子，那么假如我们用有符号整数呢？

我们知道负整数在计算机存储时是存储其补码(正整数也是，只不过其补码与原码一致)，那么我们知道一个`int32`的负数`-1`在计算机中会被存储为`11111111 11111111 11111111 11111111`，这时候即使是绝对值很小的负数使用Varint也会占用额外的字节，所以接下来就要用到ZigZag了。

#### ZigZag 

ZigZag也是一种整数压缩算法，只不过其主要针对**有符号整数**，其原理与Varint类似，也是将数字中高位中无意义的`0`移除。

但其实现方式不同，先说一下较为简单的正整数：

```go
// var t int32 = 2
00000000 00000000 00000000 00000010
```

这时候我们发现，这里面除了`10`以外，其余的`0`都是没有用的，太浪费空间了，于是我们将其符号位也就是最左侧的`0`移动到右侧末尾，然后将高位无效的0全部移除，我们得到`100`，最低位的`0`是符号位表示正负。逆向推导求原始值的过程也很简单，无非就是反着来罢了。

再来看负整数:

```
// var st int32 = -2
11111111 11111111 11111111 11111110
```
负整数的操作步骤需要两步：
1. 移动符号位到最低位
2. 对数据位求反

经过第一步后，变为`11111111 11111111 11111111 11111101`，经过第二步后，变为`00000000 00000000 00000000 00000011`，这时候我们就可以忽略高位的无效0，对其进行压缩了，最终得到`11`

最后说0，0的话最简单，最终就是0。

| 原始值 | Zigzag编码值 |
| ------ | ------------ |
| 0 | 0 |
| -1 | 1 |
| 1 | 2 |
| -2 | 3 |
| 2 | 4 |
| 2147483647| 4294967294 |
| -2147483647 | 4294967295 |

可以看到通过Zigzag编码我们得到这样的一种映射，所以看到说Zigzag是一种映射编码方案也是对的。

经过上面的例子，我们知道，十进制`2`变为二进制`100`，十进制`-2`变为二进制`11`，那么我们保存这两个值的话如何保存呢？用一个字节存储`000100 11`肯定是不行的，因为不知道这一个字节代表了几个数，也没办法知道其分割点。这时候我们就可以利用上面的`Varint`进行编码了，最终用两个字节对这两个数分别`00000100  00000011`来存储即可。所以`ZigZag`一般是需要配合`Varint`的。


接下来用go实现ZigZag(*这个地方不感兴趣额的话可以跳过*):

```go
// zigzag 算法go实现
func encode(a int32) int32 {
	return (a << 1) ^ (a >> 31)
}

func decode(b int32) int32 {
	return int32(uint32(b)>>1) ^ -(b & 1)
}
```

这是摘抄的代码，实现比较精妙，先看`encode`：
- a是非负整数，`a >> 31 == 00000000 00000000 00000000 00000000`，任何值亦或0都得原值。所以 `(a << 1) ^ (a >> 31) == (a << 1)`
- a是负整数，`a >> 31 == 11111111 11111111 11111111 11111111`，任何数抑或1都得原始值的反，所以`(a << 1) ^ (a >> 31) == ^(a << 1)`

再来看`decode`，需要注意go中没有无符号右移操作，所以会有额外转换b的操作。另外就是一个数连续两次异或同一个数所得结果为原始值。
- b是非负整数，`-(b & 1) == 00000000 00000000 00000000 00000000`，所以 encode中的`(a >> 31)` 等于 decode中的`-(b & 1)`，那么连续两次抑或同一个值后b就等于`(a << 1)`，在decode中继续对b进行无符号右移操作得到原始a的值。
- b是负数，`-(b & 1) == 11111111 11111111 11111111 11111111`，后续同上。


#### 总结

使用`Varint`和`ZigZag`相互配合的编码形式，我们可以看出：

- 对于绝对值相对较小的整数，我们可以节约空间，单独使用`Varint`的话所有小于`128`的无符号整数都可以使用一个字节表示。
- 而对于绝对值较大的整数，我们可能会额外花费空间来存储
- 在编码层面解决了“分隔符的问题”，每个字节的最高有效位为0时表示结束。所以即使有连续的多个`Varint`编码的数字我们也可以无需其他的分隔符通过编码对其分隔。


这两个编码方式就是`Protocol Buffers`的精华，理解了这两个编码方式后接下来的内容就会很简单了。

### Protocol Buffers

#### Message

`Protocol Buffers`中的实体是`Message`，一条`Message`是由一系列`key-value`组成。

一个简单的`Message`
```
message Test1 {
  optional int32 a = 1;
}

// 当我们创建一个新的 Test1消息的时候，设置a为150，我们得到以下三个字节
08 96 01

// 第一个字节, 高5位是varint编码形式，表示field number(每个键值对后面定义的序号)也就是1，低三位是wire type，这个后续讲解
0 0001 000

// 后面两个字节是varint编码的 150
1 001 0110  0 000 0001  // 1 001 0110  == 2 + 4 + 16 + 128 == 150
```

其实体为二进制，在其二进制实体中`key`不再由命名字符串组成，而是由 `field number` 以及 `wire type`组成。
- field number: 也就是定义在`.proto`文件中的键的序号。
- wire type: 定义了value的长度，定义如下：(3，4被废弃)

| Type | Meaning | Used For |
| ---- | ---- | ---- |
| 0	| Varint |	int32, int64, uint32, uint64, sint32, sint64, bool, enum |
| 1	| 64-bit |	fixed64, sfixed64, double |
| 2	| Length-delimited |	string, bytes, embedded messages, packed repeated fields |
| 5	| 32-bit | 	fixed32, sfixed32, float |

`key`的编码形式为`varint << 3 | wire type`。也就是说，低三位表示 `wire type`，高5位表示`field number`，而又因为`varint`中第一位是标志位，所以当`key`只占有一个字节时，有效位数是4位，所以官方文档中说明：
> Note that field numbers in the range 1 through 15 take one byte to encode


- 当`wire type`为0时，value表现为：
    - 无符号整数为正常的varint，但如果传入负数，就会保存负数的补码，长度会很大
    - 有符号整数。ZigZag
        - `(n << 1) ^ (n >> 31)` sint32
        - `(n << 1) ^ (n >> 63)` sint64
- 当`wire type`为1时，value就是固定占用8个字节
- 当`wire type`为5时，value就是固定占用4个字节
- 当`wire type`为2时，value表现为：
    - 首先是字节长度，使用Varint编码
    - 真正的数据


```
message Test2 {
  optional string b = 2;
}

// 首先 key 是
0 0010 010  // 低三位是wire type，值为2，最高位为标志位表示Varint编码结束，中间4位表示wire type的值

// 其次就是value了，如果value是testing，testing对应的16进制为 74 65 73 74 69 6e 67
07 74 65 73 74 69 6e 67 // 这就是value，第一个字节表示长度，后面跟对应的数据

```

#### 嵌套字段
```
message Test1 {
  optional int32 a = 1;
}

// 当我们创建一个新的 Test1消息的时候，设置a为150，我们得到以下三个字节
08 96 01

message Test3 {
  optional Test1 c = 3;
}

// 嵌套字段wire type依然是2，如果我们实例化一个Test3消息，并且设置其中Test1消息的a字段为150，那么我们得到：
1a 03 08 96 01
// 后面三个字节和之前的例子一致，第二个字节表示长度，第一个字节表示key
```

#### 可选字段和重复字段

- repeated字段编码方式
    - 在`proto2`中定义的`repeated`字段，默认传输消息体时该字段会是0个或者多个键值对的方式传输，每个键值对遵循对应的规则。并且这些键值对有可能会和其他字段交叉排列，也就是这些键值对可能不会靠在一起，这些键值对之间的顺序是不会变的。
    - 而在`proto3`或者`proto2`中在`repeated`中添加了`[packed=true]`选项后(repeated字段 wire type必须为 0，1，5这种数字类型)，编码方式就变了，最终会只有一个键值对，键不变，值的话变为`Length-delimited`格式，首先是字节长度并使用Varint编码，后面是对应的数据。
    ```
    message Test4 {
      repeated int32 d = 4 [packed=true];
    }
    
    // 当构建一个Test4，并为d字段填充值 3, 270, 86942后
    22        // key (field number 4, wire type 2)
    06        // payload size (6 bytes)
    03        // first element (varint 3)
    8E 02     // second element (varint 270)
    9E A7 05  // third element (varint 86942)
    ```
    - 假如在一个message编码中一个非 repeated 字段具有多个键值对
        - 对于数字字段或者字符串字段，解析器会将最后出现的键值对作为真正的值
        - 对于嵌入字段，解析器会首先解析第一个值，然后将第二个值merge到第一个值，以此类推。
    
#### 字段顺序

在`proto`文件中，field number定义的顺序并不影响序列化。因为序列化实现细节可能会经常变动，所以 protocol buffer解析器 设计之初就要求能解析任意顺序的字段。因此，不同版本所生成的二进制序列可能不一致。

### 参考
- [Encoding](https://developers.google.com/protocol-buffers/docs/encoding)
- [详解varint编码原理](https://segmentfault.com/a/1190000020500985)
- [小而巧的数字压缩算法：zigzag](https://blog.csdn.net/zgwangbo/article/details/51590186)

